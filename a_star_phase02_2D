#!/usr/bin/python3

# Import the necessary libraries

import numpy as np
import math
import heapq
import cv2

# import rospy
# from geometry_msgs.msg import Twist
# from std_msgs.msg import String
# import time


def make_canvas_2():
    """This function creates the map with the obstacles

    Returns:
        tuple: (obstacle, canvas)
    """    
    canvas = np.zeros((200, 600, 3), dtype="uint8")
    blue = (255,0,0)
    red = (0,0,255)

    clearance = int(input("Enter the clearance (in cm): "))
    robot_radius = 10.5
    c = int(clearance + robot_radius)

    # Obstacle rectangles

    cv2.rectangle(canvas, (150-c, 200), (165+c,75-c), blue, thickness=-1)
    cv2.rectangle(canvas, (250-c,0), (265+c,125+c), blue, thickness=-1)
    cv2.rectangle(canvas, (150,200), (165,75), red, thickness=-1)
    cv2.rectangle(canvas, (250,0), (265,125), red, thickness=-1)

    cv2.circle(canvas, (400,90), 50+c, blue, thickness=-1)
    cv2.circle(canvas, (400,90), 50, red, thickness=-1)

    # Finding all the nonzero pixels from the canvas and appending them to the list of obstacle points

    obstacle = []
    for y in range(canvas.shape[0]):
        for x in range(canvas.shape[1]):
            if canvas[y,x].any():
                obstacle.append((x,y))

    # Returning the obstacle space and the canvas image

    return obstacle, canvas

obstacle, canvas = make_canvas_2()

# Function to get the user input

def user_input():
    """Takes start and goal coordinates as user input. Also gets the step size of the robot

    Returns:
        tuple: (start_node, goal_node, radius)
    """    
    valid_input = False
    while valid_input == False:
        global start_x, start_y, clearance
        start_x = int(input("Enter X coordinate of start node (in cm) between 0 and 600: "))  # X coordinate of start node
        start_y = int(input("Enter Y coordinate of start node (in cm) between 0 and 200: "))  # Y coordinate of start node
        start_theta = int(input("Enter the theta at the start node from 0 to 360: "))    # Angle at the start node
        goal_x = int(input("Enter X coordinate of goal node (in cm) between 0 and 600: "))    # X coordinate of goal node
        goal_y = int(input("Enter Y coordinate of goal node (in cm) between 0 and 200: "))    # Y coordinate of goal node           
        rpm1 = int(input("Rpm value 1: "))
        rpm2 = int(input("Rpm value 2: "))     

        start_node = (int(start_x),int(start_y),start_theta)
        goal_node = (int(goal_x),int(goal_y))
        rpm_choices = (rpm1, rpm2)
        
        if (start_node[0], start_node[1]) in obstacle:
            print(f"Start node {start_node} is in obstacle space. Enter another node.") # Error message if start node is in obstacle space
            valid_input = False
        elif goal_node in obstacle:
            print(f"Goal node {goal_node} is in obstacle space. Enter another node") # Error message if goal node is in obstacle space
            valid_input = False
        elif start_x<0 or start_x>600 or goal_x<0 or goal_x>600 or start_y<0 or start_y>200 or goal_y<0 or goal_y>200 or start_theta<0 or start_theta>360:
            print("The coordinates you entered are beyond the scope of the map. Enter valid start and goal coordinates.") # Error message if start or goal node is beyond the scope of the map
            valid_input = False
        elif (start_node[0], start_node[1]) not in obstacle and goal_node not in obstacle:
            valid_input = True
            break
        
    return start_node, goal_node, rpm_choices
